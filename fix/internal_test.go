package fix

import (
	"bytes"
	"strings"
	"testing"
)

func split_(s string) (gcodes [][]byte) {
	b := bytes.NewBufferString(s)
	for {
		line, err := b.ReadBytes('\n')
		if err != nil {
			break
		}
		gcodes = append(gcodes, line[0:len(line)-1])
	}
	return gcodes
}

func TestConvertThumbnail(t *testing.T) {
	gcodes := split_(`; top_infill_extrusion_width = 0.4
; top_solid_infill_speed = 60%
; top_solid_layers = 6
; generated by PrusaSlicer 2.4.2+arm64 on 2022-05-12 at 06:33:34 UTC
G0
G1

;
; thumbnail begin 16x16 536
; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
; bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
; thumbnail end
;
G0
G1
;
; thumbnail begin 220x124 6528
; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
; yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
; zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
; thumbnail end
;
;

; external perimeters extrusion width = 0.45mm
; perimeters extrusion width = 0.45mm
; infill extrusion width = 0.45mm

`)

	comp := []byte("data:image/png;base64,xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz")
	r := convertThumbnail(gcodes)
	if 0 != bytes.Compare(r, comp) {
		t.Error(r, comp)
	}
}

func TestConvertEstimatedTime(t *testing.T) {
	gcodes := " 2s "
	if r := convertEstimatedTime(gcodes); 2 != r {
		t.Error("2s /", r)
	}
	gcodes = "1m 2s "
	if r := convertEstimatedTime(gcodes); 60+2 != r {
		t.Error("1m 2s /", r)
	}
	gcodes = " 1h  2s"
	if r := convertEstimatedTime(gcodes); 3600+2 != r {
		t.Error("1h 2s /", r)
	}
	gcodes = " 2d 1m  2s"
	if r := convertEstimatedTime(gcodes); 2*86400+1*60+2 != r {
		t.Error("2d 1m 2s /", r)
	}
}

func TestSplit(t *testing.T) {
	s := "a"
	r := split(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != "a" {
		t.Error("index 0 value is not a, but:", r[0])
	}
	if r[1] != "" {
		t.Error("index 1 value is not empty, but:", r[1])
	}

	s = "xxxx, yy yy "
	r = split(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != "xxxx" {
		t.Error("index 0 value is not xxxx, but:", r[0])
	}
	if r[1] != "yy yy" {
		t.Error("index 1 value is not yy yy, but:", r[1])
	}
}

func TestSplitFloat(t *testing.T) {
	s := "0.2"
	r := splitFloat(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != 0.2 {
		t.Error("index 0 value is not 0.2, but:", r[0])
	}
	if r[1] != 0 {
		t.Error("index 1 value is not 0, but:", r[1])
	}

	s = "0.4, 0.689123"
	r = splitFloat(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != 0.4 {
		t.Error("index 0 value is not 0.4, but:", r[0])
	}
	if r[1] != 0.689123 {
		t.Error("index 1 value is not 0.689123, but:", r[1])
	}

	s = "nil,123"
	r = splitFloat(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != 0 {
		t.Error("index 0 value is not 0, but:", r[0])
	}
	if r[1] != 123 {
		t.Error("index 1 value is not 123, but:", r[1])
	}

	s = "nil,789,123"
	r = splitFloat(s)
	if len(r) != 3 {
		t.Error("len is not 3, but:", len(r))
	}
	if r[0] != 0 {
		t.Error("index 0 value is not 0, but:", r[0])
	}
	if r[1] != 789 {
		t.Error("index 1 value is not 789, but:", r[1])
	}
}

func TestGcodeShutoff(t *testing.T) {
	gcode := `
T0 ; initial tool
M104 S200 T1
T1
M104 S200 T1
T0
M104 S100 T1 ; (remove useless)

M104 S200 T0
M104 S200 T1 ; (remove useless)
M109 S200 T1 ; (remove useless)

M104 S0 T0
M104 S0 T1 ; (keep)
M73 P100 R0 ; end
	`

	comp := strings.TrimSpace(`
T0 ; initial tool
M104 S200 T1
T1
M104 S200 T1
T0
M104 S0 T1 ; (Fixed: Shutoff T1)
;(Fixed: T1 has been shutted off: M104 S100 T1 ; (remove useless))

M104 S200 T0
;(Fixed: T1 has been shutted off: M104 S200 T1 ; (remove useless))
;(Fixed: T1 has been shutted off: M109 S200 T1 ; (remove useless))

M104 S0 T0
M104 S0 T1 ; (keep)
M73 P100 R0 ; end
	`)

	r := GcodeFixShutoff(strings.Split(gcode, "\n"))
	str_r := strings.TrimSpace(strings.Join(r, "\n"))
	if strings.Compare(str_r, comp) != 0 {
		t.Error(str_r + "\n\n==== comp:\n" + comp)
	}
}

func TestGcodePreheat(t *testing.T) {
	gcode := `
M73 P0 R60
M109 T0 S200
M109 T1 S210 ; prepare

; deep freeze {{
; standby but heat-up after 5 mins, need to be freeze >>
M104 S154 ;standby T0
M73 P4 R55
; pre-heat (long) here >>
M73 P4 R54
M73 P4 R53
M73 P4 R52
M73 P4 R51
M109 T0 S200 ; wait T0
;}} end deep freeze

; pre-heat short {{
M104 S154 ;standby T1
M73 P5 R43
; standby but heat-up in 3 mins, pre heat (short) here >>
M73 P5 R42
M73 P5 R41
M109 T1 S220 C3 W1 ;wait T1
; }} end pre-heat short

; remove cooldown {{
M104 S178 ;standby T0 (remove)
T1
M109 T1 S555 C3 W1 ;wait T1
M73 P6 R21
T0
M109 T0 S255 C3 W1 ;wait T0
; }} end remove cooldown

M104 S555 T1 ; <- already requested
M109 T1 S100 ; <- diff temp, keep this
M109 S100 T1; <- already stabilized

; nothing to do {{
M109 T1 S255 C3 W1 ;wait T1
M104 T0 S0
M104 T1 S0
G28 ; home
M73 P100 R0 ; end
; }}
	`

	comp := strings.TrimSpace(`
M73 P0 R60
M109 T0 S200
M109 T1 S210 ; prepare

; deep freeze {{
; standby but heat-up after 5 mins, need to be freeze >>
M104 S110 T0 ; (Fixed: deep freeze instead of: M104 S154 ;standby T0)
M73 P4 R55
; pre-heat (long) here >>
M104 T0 S200 ; wait T0(Fixed: pre-heat long)
M73 P4 R54
M73 P4 R53
M73 P4 R52
M73 P4 R51
M109 T0 S200 ; wait T0
;}} end deep freeze

; pre-heat short {{
M104 S154 ;standby T1
M73 P5 R43
; standby but heat-up in 3 mins, pre heat (short) here >>
M104 T1 S220 C3 W1 ;wait T1(Fixed: pre-heat short)
M73 P5 R42
M73 P5 R41
M109 T1 S220 C3 W1 ;wait T1
; }} end pre-heat short

; remove cooldown {{
;(Fixed: remove cooldown: M104 S178 ;standby T0 (remove))
T1
M109 T1 S555 C3 W1 ;wait T1
M73 P6 R21
T0
M109 T0 S255 C3 W1 ;wait T0
; }} end remove cooldown

;(Fixed: already requested temp: M104 S555 T1 ; <- already requested)
M109 T1 S100 ; <- diff temp, keep this
;(Fixed: already stabilized temp: M109 S100 T1; <- already stabilized)

; nothing to do {{
M109 T1 S255 C3 W1 ;wait T1
M104 T0 S0
M104 T1 S0
G28 ; home
M73 P100 R0 ; end
; }}
	`)

	r := GcodeFixPreheat(strings.Split(gcode, "\n"))
	str_r := strings.TrimSpace(strings.Join(r, "\n"))
	if strings.Compare(str_r, comp) != 0 {
		t.Error(str_r + "\n\n==== comp:\n" + comp)
	}
}

func TestGcodeTrimLines(t *testing.T) {
	gcode := `
	Line 1
Line 2

  Line 3
  ;

  G4 S0
  G4 P100

G4 S0 ; comments

Line 4




Line 5
`
	comp := `
Line 1
Line 2

Line 3
;

G4 P100

Line 4

Line 5
`

	r := GcodeTrimLines(strings.Split(gcode, "\n"))
	str_r := strings.Join(r, "\n")
	if strings.Compare(str_r, comp) != 0 {
		t.Error("\n>>>" + str_r + "<<<\n==== comp:\n>>>" + comp + "<<<\n")
	}
}

func TestGcodeReinforceTower(t *testing.T) {
	gcodes := `
G1  X176.579  E4.2970 F1584
;Z:0.3
; CP TOOLCHANGE WIPE
G1  X176.579  E1.2970 F1584
G1  Y31.500  E0.1900
G1  X142.329  E1.3017 F1800
G1 F19200
G92 E0
; CP TOOLCHANGE END
;Z:0.4
G1  X176.579  E1.2970 F1584
; CP TOOLCHANGE WIPE
M73 R80
G1  X176.579  E2.2970 F1584
G1  Y31.500  E0.1900
G1  X176.579  E4.3017 F2198
G1  Y36.500  E0.1900
G1  X176.579  E4.3017 F2198
G1 F19200
G92 E0
; CP TOOLCHANGE END
G1  X176.579  E1.2970 F1584
`
	comp := `
G1  X176.579  E4.2970 F1584
;Z:0.3
; CP TOOLCHANGE WIPE
G1  X176.579  E1.2970 F1584
G1  Y31.500  E0.1900
G1  X142.329  E1.3017 F1800
G1 F19200
G92 E0
; CP TOOLCHANGE END
;Z:0.4
G1  X176.579  E1.2970 F1584
; CP TOOLCHANGE WIPE
M73 R80
G1 E1.0337 F1584 ; (Fixed: reinforce tower)
G1  X176.579  E2.2970 F1584
G1  Y31.500  E0.1900
G1 E1.0337 F1584 ; (Fixed: reinforce tower)
G1  X176.579  E4.3017 F2198
G1  Y36.500  E0.1900
G1 E1.0337 F1584 ; (Fixed: reinforce tower)
G1  X176.579  E4.3017 F2198
G1 F19200
G92 E0
; CP TOOLCHANGE END
G1  X176.579  E1.2970 F1584
`

	r := GcodeReinforceTower(strings.Split(gcodes, "\n"))
	str_r := strings.Join(r, "\n")
	if strings.Compare(str_r, comp) != 0 {
		t.Error("\n>>>" + str_r + "<<<\n==== comp:\n>>>" + comp + "<<<\n")
	}
}
