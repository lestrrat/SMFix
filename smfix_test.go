package main

import (
	"bytes"
	"testing"
)

func split_(s string) (gcodes [][]byte) {
	b := bytes.NewBufferString(s)
	for {
		line, err := b.ReadBytes('\n')
		if err != nil {
			break
		}
		gcodes = append(gcodes, line[0:len(line)-1])
	}
	return gcodes
}

func TestConvertThumbnail(t *testing.T) {
	gcodes := split_(`; top_infill_extrusion_width = 0.4
; top_solid_infill_speed = 60%
; top_solid_layers = 6
; generated by PrusaSlicer 2.4.2+arm64 on 2022-05-12 at 06:33:34 UTC
G0
G1

;
; thumbnail begin 16x16 536
; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
; bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
; thumbnail end
;
G0
G1
;
; thumbnail begin 220x124 6528
; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
; yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
; zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
; thumbnail end
;
;

; external perimeters extrusion width = 0.45mm
; perimeters extrusion width = 0.45mm
; infill extrusion width = 0.45mm

`)

	comp := []byte("data:image/png;base64,xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz")
	r := convertThumbnail(gcodes)
	if 0 != bytes.Compare(r, comp) {
		t.Error(r, comp)
	}
}

func TestConvertEstimatedTime(t *testing.T) {
	gcodes := " 2s "
	if r := convertEstimatedTime(gcodes); 2 != r {
		t.Error("2s /", r)
	}
	gcodes = "1m 2s "
	if r := convertEstimatedTime(gcodes); 60+2 != r {
		t.Error("1m 2s /", r)
	}
	gcodes = " 1h  2s"
	if r := convertEstimatedTime(gcodes); 3600+2 != r {
		t.Error("1h 2s /", r)
	}
	gcodes = " 2d 1m  2s"
	if r := convertEstimatedTime(gcodes); 2*86400+1*60+2 != r {
		t.Error("2d 1m 2s /", r)
	}
}

func TestSplit(t *testing.T) {
	s := "a"
	r := split(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != "a" {
		t.Error("index 0 value is not a, but:", r[0])
	}
	if r[1] != "" {
		t.Error("index 1 value is not empty, but:", r[1])
	}

	s = "xxxx, yy yy "
	r = split(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != "xxxx" {
		t.Error("index 0 value is not xxxx, but:", r[0])
	}
	if r[1] != "yy yy" {
		t.Error("index 1 value is not yy yy, but:", r[1])
	}
}

func TestSplitFloat(t *testing.T) {
	s := "0.2"
	r := splitFloat(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != 0.2 {
		t.Error("index 0 value is not 0.2, but:", r[0])
	}
	if r[1] != 0 {
		t.Error("index 1 value is not 0, but:", r[1])
	}

	s = "0.4, 0.689123"
	r = splitFloat(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != 0.4 {
		t.Error("index 0 value is not 0.4, but:", r[0])
	}
	if r[1] != 0.689123 {
		t.Error("index 1 value is not 0.689123, but:", r[1])
	}

	s = "nil,123"
	r = splitFloat(s)
	if len(r) != 2 {
		t.Error("len is not 2, but:", len(r))
	}
	if r[0] != 0 {
		t.Error("index 0 value is not 0, but:", r[0])
	}
	if r[1] != 123 {
		t.Error("index 1 value is not 123, but:", r[1])
	}

	s = "nil,789,123"
	r = splitFloat(s)
	if len(r) != 3 {
		t.Error("len is not 3, but:", len(r))
	}
	if r[0] != 0 {
		t.Error("index 0 value is not 0, but:", r[0])
	}
	if r[1] != 789 {
		t.Error("index 1 value is not 789, but:", r[1])
	}
}
